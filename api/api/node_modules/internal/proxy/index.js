'use strict';

// request next tick, depending on the environment
var raf = (() => (typeof window === 'undefined' ? (typeof process === 'undefined' ? (fn) => setTimeout(fn, 0) : process.nextTick) : window.requestAnimationFrame))();

// imports

// Proxy type





// proxy function
function proxy(target) {
  if (typeof Proxy === 'undefined') {
    throw new Error('proxy: requires ES6 proxies to work properly')
  }
  const fns = [];
  let dirty = false;
  // debounce the trigger
  function debounce() {
    dirty = true;
    raf(trigger);
  }
  // trigger the subscribers
  function trigger() {
    if (!dirty) {
      return
    }
    for (let i = 0; i < fns.length; i++) {
      fns[i]();
    }
    dirty = false;
  }
  // attach subscribe and unsubscribe to the top-level proxy
  return Object.assign(proxy2(target, debounce), {
    subscribe(fn) {
      fns.push(fn);
    },
    unsubscribe(fn) {
      const i = fns.indexOf(fn);
      if (~i) fns.splice(i, 1);
    },
  })
}

// add toValue
// TODO: in the future, we may want to be more clever
proxy.toValue = function(proxied) {
  return JSON.parse(JSON.stringify(proxied))
};

// recursive and responsible for the proxying
function proxy2(state, trigger) {
  return new Proxy(state, {
    set: function(target, property, value, receiver) {
      Reflect.set(target, property, value, receiver);
      trigger();
      return true
    },
    get: function(target, property, receiver) {
      const value = Reflect.get(target, property, receiver);
      if (typeof value === 'object') {
        return proxy2(value, trigger)
      }
      return value
    },
  })
}

module.exports = proxy;
