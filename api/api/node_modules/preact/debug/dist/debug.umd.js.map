{"version":3,"file":"debug.umd.js","sources":["../src/check-props.js","../src/devtools/custom.js","../src/constants.js","../src/component-stack.js","../src/debug.js","../src/devtools/renderer.js","../src/devtools/10/IdMapper.js","../src/devtools/10/string-table.js","../src/devtools/10/vnode.js","../src/devtools/10/filter.js","../src/devtools/10/utils.js","../src/devtools/10/constants.js","../src/devtools/10/renderer.js","../src/devtools/index.js","../src/index.js","../src/devtools/10/options.js"],"sourcesContent":["const ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nlet loggedTypeFailures = {};\n\nexport function checkPropTypes(\n\ttypeSpecs,\n\tvalues,\n\tlocation,\n\tcomponentName,\n\tgetStack\n) {\n\tObject.keys(typeSpecs).forEach(typeSpecName => {\n\t\tlet error;\n\t\ttry {\n\t\t\terror = typeSpecs[typeSpecName](\n\t\t\t\tvalues,\n\t\t\t\ttypeSpecName,\n\t\t\t\tcomponentName,\n\t\t\t\tlocation,\n\t\t\t\tnull,\n\t\t\t\tReactPropTypesSecret\n\t\t\t);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\t\tif (error && !(error.message in loggedTypeFailures)) {\n\t\t\tloggedTypeFailures[error.message] = true;\n\t\t\tconsole.error(\n\t\t\t\t`Failed ${location} type: ${error.message}${(getStack && getStack()) ||\n\t\t\t\t\t''}`\n\t\t\t);\n\t\t}\n\t});\n}\n","/* istanbul ignore file */\nimport { Component, Fragment } from 'preact';\n\n/**\n * Get the type/category of a vnode\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').NodeType}\n */\nexport function getNodeType(vnode) {\n\tif (vnode.type === Fragment) return 'Wrapper';\n\telse if (typeof vnode.type === 'function') return 'Composite';\n\telse if (typeof vnode.type === 'string') return 'Native';\n\treturn 'Text';\n}\n\n/**\n * Get human readable name of the component/dom element\n * @param {import('../internal').VNode} vnode\n * @returns {string}\n */\nexport function getDisplayName(vnode) {\n\tif (vnode.type === Fragment) {\n\t\treturn 'Fragment';\n\t} else if (typeof vnode.type === 'function') {\n\t\treturn vnode.type.displayName || vnode.type.name;\n\t} else if (typeof vnode.type === 'string') {\n\t\treturn vnode.type;\n\t}\n\n\treturn '#text';\n}\n\n/**\n * Deeply mutate a property by walking down an array of property keys\n * @param {object} obj\n * @param {Array<string | number>} path\n * @param {any} value\n */\nexport function setIn(obj, path, value) {\n\tlet last = path.pop();\n\tlet parent = path.reduce((acc, attr) => (acc ? acc[attr] : null), obj);\n\tif (parent) {\n\t\tparent[last] = value;\n\t}\n}\n\n/**\n * Get devtools compatible data from vnode\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').DevtoolData}\n */\nexport function getData(vnode) {\n\tlet c = vnode._component;\n\n\t/** @type {import('../internal').DevtoolsUpdater | null} */\n\tlet updater = null;\n\n\tif (c != null && c instanceof Component) {\n\t\t// These functions will be called when the user changes state, props or\n\t\t// context values via the devtools ui panel\n\t\tupdater = {\n\t\t\tsetState: c.setState.bind(c),\n\t\t\tforceUpdate: c.forceUpdate.bind(c),\n\t\t\tsetInState(path, value) {\n\t\t\t\tc.setState(prev => {\n\t\t\t\t\tsetIn(prev, path, value);\n\t\t\t\t\treturn prev;\n\t\t\t\t});\n\t\t\t},\n\t\t\tsetInProps(path, value) {\n\t\t\t\tsetIn(vnode.props, path, value);\n\t\t\t\tc.setState({});\n\t\t\t},\n\t\t\tsetInContext(path, value) {\n\t\t\t\tsetIn(c.context, path, value);\n\t\t\t\tc.setState({});\n\t\t\t}\n\t\t};\n\t}\n\n\tlet children = getChildren(vnode);\n\n\tlet duration = vnode.endTime - vnode.startTime;\n\treturn {\n\t\tnodeType: getNodeType(vnode),\n\t\ttype: vnode.type,\n\t\tname: getDisplayName(vnode),\n\t\tref: vnode.ref || null,\n\t\tkey: vnode.key || null,\n\t\tupdater,\n\t\ttext: vnode.type === null ? vnode.props : null,\n\t\tstate: c != null && c instanceof Component ? c.state : null,\n\t\tprops: vnode.props,\n\t\t// The devtools inline text children if they are the only child\n\t\tchildren:\n\t\t\tvnode.type !== null\n\t\t\t\t? children != null && children.length == 1 && children[0].type === null\n\t\t\t\t\t? children[0].props\n\t\t\t\t\t: children\n\t\t\t\t: null,\n\t\tpublicInstance: getInstance(vnode),\n\t\tmemoizedInteractions: [],\n\n\t\t// Profiler data\n\t\tactualDuration: duration,\n\t\tactualStartTime: vnode.startTime,\n\t\ttreeBaseDuration: duration\n\t};\n}\n\n/**\n * Get all rendered vnode children as an array. Moreover we need to filter\n * out `null` or other falsy children.\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').VNode[]}\n */\nexport function getChildren(vnode) {\n\tif (vnode._component == null) {\n\t\treturn vnode._children != null ? vnode._children.filter(Boolean) : [];\n\t}\n\n\treturn vnode._children != null ? vnode._children.filter(Boolean) : null;\n}\n\n/**\n * Check if a vnode is a root node\n * @param {import('../internal').VNode} vnode\n * @returns {boolean}\n */\nexport function isRoot(vnode) {\n\t// Timings of root vnodes will never be set\n\treturn vnode.type === Fragment && vnode._parent === null;\n}\n\n/**\n * Cache a vnode by its instance and retrieve previous vnodes by the next\n * instance.\n *\n * We need this to be able to identify the previous vnode of a given instance.\n * For components we want to check if we already rendered it and use the class\n * instance as key. For html elements we use the dom node as key.\n *\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').Component | import('../internal').PreactElement | Text | null}\n */\nexport function getInstance(vnode) {\n\t// Use the parent element as instance for root nodes\n\tif (isRoot(vnode)) {\n\t\t// Edge case: When the tree only consists of components that have not rendered\n\t\t// anything into the DOM we revert to using the vnode as instance.\n\t\treturn vnode._children.length > 0 &&\n\t\t\tvnode._children[0] != null &&\n\t\t\tvnode._children[0]._dom != null\n\t\t\t? /** @type {import('../internal').PreactElement | null} */\n\t\t\t  (vnode._children[0]._dom.parentNode)\n\t\t\t: vnode;\n\t}\n\tif (vnode._component != null) return vnode._component;\n\tif (vnode.type === Fragment) return vnode.props;\n\treturn vnode._dom;\n}\n\n/**\n * Compare two objects\n * @param {object} a\n * @param {object} b\n * @param {boolean} [isProps]\n * @returns {boolean}\n */\nexport function shallowEqual(a, b, isProps) {\n\tif (a == null || b == null) return false;\n\n\tfor (let key in a) {\n\t\tif (isProps && key == 'children' && b[key] != null) continue;\n\t\tif (a[key] !== b[key]) return false;\n\t}\n\n\tif (Object.keys(a).length !== Object.keys(b).length) return false;\n\treturn true;\n}\n\n/**\n * Check if a vnode was actually updated\n * @param {import('../internal').VNode} next\n * @param {import('../internal').VNode} prev\n * @returns {boolean}\n */\nexport function hasDataChanged(prev, next) {\n\treturn (\n\t\t(prev.props !== next.props &&\n\t\t\t!shallowEqual(prev.props, next.props, true)) ||\n\t\t(prev._component != null &&\n\t\t\t!shallowEqual(next._component._prevState, next._component.state)) ||\n\t\tprev._dom !== next._dom ||\n\t\tprev.ref !== next.ref\n\t);\n}\n","export const ELEMENT_NODE = 1;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n","import { options, Fragment } from 'preact';\nimport { getDisplayName } from './devtools/custom';\n\n/**\n * Used to keep track of the currently rendered `vnode` and print it\n * in debug messages.\n */\nlet renderStack = [];\n\n/**\n * Keep track of the current owners. An owner describes a component\n * which was responsible to render a specific `vnode`. This exclude\n * children that are passed via `props.children`, because they belong\n * to the parent owner.\n *\n * ```jsx\n * const Foo = props => <div>{props.children}</div> // div's owner is Foo\n * const Bar = props => {\n *   return (\n *     <Foo><span /></Foo> // Foo's owner is Bar, span's owner is Bar\n *   )\n * }\n * ```\n *\n * Note: A `vnode` may be hoisted to the root scope due to compiler\n * optimiztions. In these cases the `_owner` will be different.\n */\nlet ownerStack = [];\n\n/**\n * Get the currently rendered `vnode`\n * @returns {import('./internal').VNode | null}\n */\nexport function getCurrentVNode() {\n\treturn renderStack.length > 0 ? renderStack[renderStack.length - 1] : null;\n}\n\n/**\n * If the user doesn't have `@babel/plugin-transform-react-jsx-source`\n * somewhere in his tool chain we can't print the filename and source\n * location of a component. In that case we just omit that, but we'll\n * print a helpful message to the console, notifying the user of it.\n */\nlet hasBabelPlugin = false;\n\n/**\n * Check if a `vnode` is a possible owner.\n * @param {import('./internal').VNode} vnode\n */\nfunction isPossibleOwner(vnode) {\n\treturn typeof vnode.type === 'function' && vnode.type !== Fragment;\n}\n\n/**\n * Return the component stack that was captured up to this point.\n * @param {import('./internal').VNode} vnode\n * @returns {string}\n */\nexport function getOwnerStack(vnode) {\n\tconst stack = [vnode];\n\tlet next = vnode;\n\twhile (next._owner != null) {\n\t\tstack.push(next._owner);\n\t\tnext = next._owner;\n\t}\n\n\treturn stack.reduce((acc, owner) => {\n\t\tacc += `  in ${getDisplayName(owner)}`;\n\n\t\tconst source = owner.__source;\n\t\tif (source) {\n\t\t\tacc += ` (at ${source.fileName}:${source.lineNumber})`;\n\t\t} else if (!hasBabelPlugin) {\n\t\t\thasBabelPlugin = true;\n\t\t\tconsole.warn(\n\t\t\t\t'Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.'\n\t\t\t);\n\t\t}\n\n\t\treturn (acc += '\\n');\n\t}, '');\n}\n\n/**\n * Setup code to capture the component trace while rendering. Note that\n * we cannot simply traverse `vnode._parent` upwards, because we have some\n * debug messages for `this.setState` where the `vnode` is `undefined`.\n */\nexport function setupComponentStack() {\n\tlet oldDiff = options._diff;\n\tlet oldDiffed = options.diffed;\n\tlet oldRoot = options._root;\n\tlet oldVNode = options.vnode;\n\tlet oldRender = options._render;\n\n\toptions.diffed = vnode => {\n\t\tif (isPossibleOwner(vnode)) {\n\t\t\townerStack.pop();\n\t\t}\n\t\trenderStack.pop();\n\t\tif (oldDiffed) oldDiffed(vnode);\n\t};\n\n\toptions._diff = vnode => {\n\t\tif (isPossibleOwner(vnode)) {\n\t\t\trenderStack.push(vnode);\n\t\t}\n\t\tif (oldDiff) oldDiff(vnode);\n\t};\n\n\toptions._root = (vnode, parent) => {\n\t\townerStack = [];\n\t\tif (oldRoot) oldRoot(vnode, parent);\n\t};\n\n\toptions.vnode = vnode => {\n\t\tvnode._owner =\n\t\t\townerStack.length > 0 ? ownerStack[ownerStack.length - 1] : null;\n\t\tif (oldVNode) oldVNode(vnode);\n\t};\n\n\toptions._render = vnode => {\n\t\tif (isPossibleOwner(vnode)) {\n\t\t\townerStack.push(vnode);\n\t\t}\n\n\t\tif (oldRender) oldRender(vnode);\n\t};\n}\n","import { checkPropTypes } from './check-props';\nimport { getDisplayName } from './devtools/custom';\nimport { options, Component } from 'preact';\nimport {\n\tELEMENT_NODE,\n\tDOCUMENT_NODE,\n\tDOCUMENT_FRAGMENT_NODE\n} from './constants';\nimport {\n\tgetOwnerStack,\n\tsetupComponentStack,\n\tgetCurrentVNode\n} from './component-stack';\n\nconst isWeakMapSupported = typeof WeakMap === 'function';\n\nfunction getClosestDomNodeParent(parent) {\n\tif (!parent) return {};\n\tif (typeof parent.type === 'function') {\n\t\treturn getClosestDomNodeParent(parent._parent);\n\t}\n\treturn parent;\n}\n\nexport function initDebug() {\n\tsetupComponentStack();\n\n\t/* eslint-disable no-console */\n\tlet oldBeforeDiff = options._diff;\n\tlet oldDiffed = options.diffed;\n\tlet oldVnode = options.vnode;\n\tlet oldCatchError = options._catchError;\n\tlet oldRoot = options._root;\n\tlet oldHook = options._hook;\n\tconst warnedComponents = !isWeakMapSupported\n\t\t? null\n\t\t: {\n\t\t\t\tuseEffect: new WeakMap(),\n\t\t\t\tuseLayoutEffect: new WeakMap(),\n\t\t\t\tlazyPropTypes: new WeakMap()\n\t\t  };\n\n\toptions._catchError = (error, vnode, oldVNode) => {\n\t\tlet component = vnode && vnode._component;\n\t\tif (component && typeof error.then === 'function') {\n\t\t\tconst promise = error;\n\t\t\terror = new Error(\n\t\t\t\t`Missing Suspense. The throwing component was: ${getDisplayName(vnode)}`\n\t\t\t);\n\n\t\t\tlet parent = vnode;\n\t\t\tfor (; parent; parent = parent._parent) {\n\t\t\t\tif (parent._component && parent._component._childDidSuspend) {\n\t\t\t\t\terror = promise;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We haven't recovered and we know at this point that there is no\n\t\t\t// Suspense component higher up in the tree\n\t\t\tif (error instanceof Error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\toldCatchError(error, vnode, oldVNode);\n\t};\n\n\toptions._root = (vnode, parentNode) => {\n\t\tif (!parentNode) {\n\t\t\tthrow new Error(\n\t\t\t\t'Undefined parent passed to render(), this is the second argument.\\n' +\n\t\t\t\t\t'Check if the element is available in the DOM/has the correct id.'\n\t\t\t);\n\t\t}\n\t\tlet isValid;\n\t\tswitch (parentNode.nodeType) {\n\t\t\tcase ELEMENT_NODE:\n\t\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\tcase DOCUMENT_NODE:\n\t\t\t\tisValid = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tisValid = false;\n\t\t}\n\t\tif (!isValid) {\n\t\t\tlet componentName = getDisplayName(vnode);\n\t\t\tthrow new Error(\n\t\t\t\t`Expected a valid HTML node as a second argument to render.\tReceived ${parentNode} instead: render(<${componentName} />, ${parentNode});`\n\t\t\t);\n\t\t}\n\n\t\tif (oldRoot) oldRoot(vnode, parentNode);\n\t};\n\n\toptions._diff = vnode => {\n\t\tlet { type, _parent: parent } = vnode;\n\t\tlet parentVNode = getClosestDomNodeParent(parent);\n\n\t\tif (type === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t'Undefined component passed to createElement()\\n\\n' +\n\t\t\t\t\t'You likely forgot to export your component or might have mixed up default and named imports' +\n\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t);\n\t\t} else if (type != null && typeof type === 'object') {\n\t\t\tif (type._lastDomChild !== undefined && type._dom !== undefined) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid type passed to createElement(): ${type}\\n\\n` +\n\t\t\t\t\t\t'Did you accidentally pass a JSX literal as JSX twice?\\n\\n' +\n\t\t\t\t\t\t`  let My${getDisplayName(vnode)} = ${serializeVNode(type)};\\n` +\n\t\t\t\t\t\t`  let vnode = <My${getDisplayName(vnode)} />;\\n\\n` +\n\t\t\t\t\t\t'This usually happens when you export a JSX literal and not the component.' +\n\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t'Invalid type passed to createElement(): ' +\n\t\t\t\t\t(Array.isArray(type) ? 'array' : type)\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\t(type === 'thead' || type === 'tfoot' || type === 'tbody') &&\n\t\t\tparentVNode.type !== 'table'\n\t\t) {\n\t\t\tconsole.error(\n\t\t\t\t'Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent.' +\n\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t);\n\t\t} else if (\n\t\t\ttype === 'tr' &&\n\t\t\t(parentVNode.type !== 'thead' &&\n\t\t\t\tparentVNode.type !== 'tfoot' &&\n\t\t\t\tparentVNode.type !== 'tbody' &&\n\t\t\t\tparentVNode.type !== 'table')\n\t\t) {\n\t\t\tconsole.error(\n\t\t\t\t'Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent.' +\n\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t);\n\t\t} else if (type === 'td' && parentVNode.type !== 'tr') {\n\t\t\tconsole.error(\n\t\t\t\t'Improper nesting of table. Your <td> should have a <tr> parent.' +\n\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t);\n\t\t} else if (type === 'th' && parentVNode.type !== 'tr') {\n\t\t\tconsole.error(\n\t\t\t\t'Improper nesting of table. Your <th> should have a <tr>.' +\n\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\tvnode.ref !== undefined &&\n\t\t\ttypeof vnode.ref !== 'function' &&\n\t\t\ttypeof vnode.ref !== 'object' &&\n\t\t\t!('$$typeof' in vnode) // allow string refs when preact-compat is installed\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`Component's \"ref\" property should be a function, or an object created ` +\n\t\t\t\t\t`by createRef(), but got [${typeof vnode.ref}] instead\\n` +\n\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t);\n\t\t}\n\n\t\tif (typeof vnode.type === 'string') {\n\t\t\tfor (const key in vnode.props) {\n\t\t\t\tif (\n\t\t\t\t\tkey[0] === 'o' &&\n\t\t\t\t\tkey[1] === 'n' &&\n\t\t\t\t\ttypeof vnode.props[key] !== 'function' &&\n\t\t\t\t\tvnode.props[key] != null\n\t\t\t\t) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Component's \"${key}\" property should be a function, ` +\n\t\t\t\t\t\t\t`but got [${typeof vnode.props[key]}] instead\\n` +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check prop-types if available\n\t\tif (typeof vnode.type === 'function' && vnode.type.propTypes) {\n\t\t\tif (\n\t\t\t\tvnode.type.displayName === 'Lazy' &&\n\t\t\t\twarnedComponents &&\n\t\t\t\t!warnedComponents.lazyPropTypes.has(vnode.type)\n\t\t\t) {\n\t\t\t\tconst m =\n\t\t\t\t\t'PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ';\n\t\t\t\ttry {\n\t\t\t\t\tconst lazyVNode = vnode.type();\n\t\t\t\t\twarnedComponents.lazyPropTypes.set(vnode.type, true);\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\tm + `Component wrapped in lazy() is ${getDisplayName(lazyVNode)}`\n\t\t\t\t\t);\n\t\t\t\t} catch (promise) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\tm + \"We will log the wrapped component's name once it is loaded.\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckPropTypes(\n\t\t\t\tvnode.type.propTypes,\n\t\t\t\tvnode.props,\n\t\t\t\tgetDisplayName(vnode),\n\t\t\t\tserializeVNode(vnode)\n\t\t\t);\n\t\t}\n\n\t\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n\t};\n\n\toptions._hook = comp => {\n\t\tif (!comp) {\n\t\t\tthrow new Error('Hook can only be invoked from render methods.');\n\t\t}\n\n\t\tif (oldHook) oldHook(comp);\n\t};\n\n\tconst warn = (property, err) => ({\n\t\tget() {\n\t\t\tthrow new Error(`getting vnode.${property} is deprecated, ${err}`);\n\t\t},\n\t\tset() {\n\t\t\tthrow new Error(`setting vnode.${property} is not allowed, ${err}`);\n\t\t}\n\t});\n\n\tconst deprecatedAttributes = {\n\t\tnodeName: warn('nodeName', 'use vnode.type'),\n\t\tattributes: warn('attributes', 'use vnode.props'),\n\t\tchildren: warn('children', 'use vnode.props.children')\n\t};\n\n\toptions.vnode = vnode => {\n\t\tlet source, self;\n\t\tif (vnode.props && vnode.props.__source) {\n\t\t\tsource = vnode.props.__source;\n\t\t\tdelete vnode.props.__source;\n\t\t}\n\t\tif (vnode.props && vnode.props.__self) {\n\t\t\tself = vnode.props.__self;\n\t\t\tdelete vnode.props.__self;\n\t\t}\n\t\tvnode.__self = self;\n\t\tvnode.__source = source;\n\t\tObject.defineProperties(vnode, deprecatedAttributes);\n\t\tif (oldVnode) oldVnode(vnode);\n\t};\n\n\toptions.diffed = vnode => {\n\t\t// Check if the user passed plain objects as children. Note that we cannot\n\t\t// move this check into `options.vnode` because components can receive\n\t\t// children in any shape they want (e.g.\n\t\t// `<MyJSONFormatter>{{ foo: 123, bar: \"abc\" }}</MyJSONFormatter>`).\n\t\t// Putting this check in `options.diffed` ensures that\n\t\t// `vnode._children` is set and that we only validate the children\n\t\t// that were actually rendered.\n\t\tif (vnode._children) {\n\t\t\tvnode._children.forEach(child => {\n\t\t\t\tif (child && child.type === undefined) {\n\t\t\t\t\t// Remove internal vnode keys that will always be patched\n\t\t\t\t\tdelete child._parent;\n\t\t\t\t\tdelete child._depth;\n\t\t\t\t\tconst keys = Object.keys(child).join(',');\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Objects are not valid as a child. Encountered an object with the keys {${keys}}.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t/** @type {import('./internal').Component} */\n\t\tconst component = vnode._component;\n\t\tif (component && component.__hooks) {\n\t\t\tlet hooks = component.__hooks;\n\t\t\tif (Array.isArray(hooks._list)) {\n\t\t\t\thooks._list.forEach(hook => {\n\t\t\t\t\tif (hook._factory && (!hook._args || !Array.isArray(hook._args))) {\n\t\t\t\t\t\tlet componentName = getDisplayName(vnode);\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t`In ${componentName} you are calling useMemo/useCallback without passing arguments.\\n` +\n\t\t\t\t\t\t\t\t`This is a noop since it will not be able to memoize, it will execute it every render.` +\n\t\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// After paint effects\n\t\t\tif (Array.isArray(hooks._pendingEffects)) {\n\t\t\t\thooks._pendingEffects.forEach(effect => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!Array.isArray(effect._args) &&\n\t\t\t\t\t\twarnedComponents &&\n\t\t\t\t\t\t!warnedComponents.useEffect.has(vnode.type)\n\t\t\t\t\t) {\n\t\t\t\t\t\twarnedComponents.useEffect.set(vnode.type, true);\n\t\t\t\t\t\tlet componentName = getDisplayName(vnode);\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t'You should provide an array of arguments as the second argument to the \"useEffect\" hook.\\n\\n' +\n\t\t\t\t\t\t\t\t'Not doing so will invoke this effect on every render.\\n\\n' +\n\t\t\t\t\t\t\t\t`This effect can be found in the render of ${componentName}.` +\n\t\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Layout Effects\n\t\t\tcomponent._renderCallbacks.forEach(possibleEffect => {\n\t\t\t\tif (\n\t\t\t\t\tpossibleEffect._value &&\n\t\t\t\t\t!Array.isArray(possibleEffect._args) &&\n\t\t\t\t\twarnedComponents &&\n\t\t\t\t\t!warnedComponents.useLayoutEffect.has(vnode.type)\n\t\t\t\t) {\n\t\t\t\t\twarnedComponents.useLayoutEffect.set(vnode.type, true);\n\t\t\t\t\tlet componentName = getDisplayName(vnode);\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t'You should provide an array of arguments as the second argument to the \"useLayoutEffect\" hook.\\n\\n' +\n\t\t\t\t\t\t\t'Not doing so will invoke this effect on every render.\\n\\n' +\n\t\t\t\t\t\t\t`This effect can be found in the render of ${componentName}.` +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (oldDiffed) oldDiffed(vnode);\n\n\t\tif (vnode._children != null) {\n\t\t\tconst keys = [];\n\t\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\t\tconst child = vnode._children[i];\n\t\t\t\tif (!child || child.key == null) continue;\n\n\t\t\t\tconst key = child.key;\n\t\t\t\tif (keys.indexOf(key) !== -1) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Following component has two or more children with the ' +\n\t\t\t\t\t\t\t`same key attribute: \"${key}\". This may cause glitches and misbehavior ` +\n\t\t\t\t\t\t\t'in rendering process. Component: \\n\\n' +\n\t\t\t\t\t\t\tserializeVNode(vnode) +\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\n\t\t\t\t\t);\n\n\t\t\t\t\t// Break early to not spam the console\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tkeys.push(key);\n\t\t\t}\n\t\t}\n\t};\n}\n\nconst setState = Component.prototype.setState;\nComponent.prototype.setState = function(update, callback) {\n\tif (this._vnode == null) {\n\t\tconsole.warn(\n\t\t\t`Calling \"this.setState\" inside the constructor of a component is a ` +\n\t\t\t\t`no-op and might be a bug in your application. Instead, set ` +\n\t\t\t\t`\"this.state = {}\" directly.\\n\\n${getOwnerStack(getCurrentVNode())}`\n\t\t);\n\t} else if (this._parentDom == null) {\n\t\tconsole.warn(\n\t\t\t`Can't call \"this.setState\" on an unmounted component. This is a no-op, ` +\n\t\t\t\t`but it indicates a memory leak in your application. To fix, cancel all ` +\n\t\t\t\t`subscriptions and asynchronous tasks in the componentWillUnmount method.` +\n\t\t\t\t`\\n\\n${getOwnerStack(this._vnode)}`\n\t\t);\n\t}\n\n\treturn setState.call(this, update, callback);\n};\n\nconst forceUpdate = Component.prototype.forceUpdate;\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode == null) {\n\t\tconsole.warn(\n\t\t\t`Calling \"this.forceUpdate\" inside the constructor of a component is a ` +\n\t\t\t\t`no-op and might be a bug in your application.\\n\\n${getOwnerStack(\n\t\t\t\t\tgetCurrentVNode()\n\t\t\t\t)}`\n\t\t);\n\t} else if (this._parentDom == null) {\n\t\tconsole.warn(\n\t\t\t`Can't call \"this.setState\" on an unmounted component. This is a no-op, ` +\n\t\t\t\t`but it indicates a memory leak in your application. To fix, cancel all ` +\n\t\t\t\t`subscriptions and asynchronous tasks in the componentWillUnmount method.` +\n\t\t\t\t`\\n\\n${getOwnerStack(this._vnode)}`\n\t\t);\n\t}\n\treturn forceUpdate.call(this, callback);\n};\n\n/**\n * Serialize a vnode tree to a string\n * @param {import('./internal').VNode} vnode\n * @returns {string}\n */\nexport function serializeVNode(vnode) {\n\tlet { props } = vnode;\n\tlet name = getDisplayName(vnode);\n\n\tlet attrs = '';\n\tfor (let prop in props) {\n\t\tif (props.hasOwnProperty(prop) && prop !== 'children') {\n\t\t\tlet value = props[prop];\n\n\t\t\t// If it is an object but doesn't have toString(), use Object.toString\n\t\t\tif (typeof value === 'function') {\n\t\t\t\tvalue = `function ${value.displayName || value.name}() {}`;\n\t\t\t}\n\n\t\t\tvalue =\n\t\t\t\tObject(value) === value && !value.toString\n\t\t\t\t\t? Object.prototype.toString.call(value)\n\t\t\t\t\t: value + '';\n\n\t\t\tattrs += ` ${prop}=${JSON.stringify(value)}`;\n\t\t}\n\t}\n\n\tlet children = props.children;\n\treturn `<${name}${attrs}${\n\t\tchildren && children.length ? '>..</' + name + '>' : ' />'\n\t}`;\n}\n","/* istanbul ignore file */\nimport {\n\tgetData,\n\tgetChildren,\n\tgetInstance,\n\thasDataChanged,\n\tisRoot\n} from './custom';\n\n/**\n * Custom renderer tailored for Preact. It converts updated vnode trees\n * to events the devtools can understand.\n * @class Renderer\n */\nexport class Renderer {\n\tconstructor(hook, rid) {\n\t\t/** @type {string} */\n\t\tthis.rid = rid;\n\t\tthis.hook = hook;\n\n\t\t/** @type {Array<import('../internal').DevtoolsEvent>} */\n\t\tthis.pending = [];\n\n\t\t/**\n\t\t * Store the instance of a vnode. This will be later used to decide if a\n\t\t * vnode needs to be mounted or updated. For components the instance refers\n\t\t * to the actual class instance whereas for dom nodes it refers to the\n\t\t * underlying dom element.\n\t\t * @type {WeakMap<import('../internal').Component | import('../internal').PreactElement | HTMLElement | Text, import('../internal').VNode>}\n\t\t */\n\t\tthis.inst2vnode = new WeakMap();\n\t\tthis.connected = false;\n\t}\n\n\t/**\n\t * Mark the connection status as ready so that we can proceed\n\t * to actually flush events.\n\t */\n\tmarkConnected() {\n\t\tthis.connected = true;\n\t\tthis.flushPendingEvents();\n\t}\n\n\t/**\n\t * Flush all queued events\n\t */\n\tflushPendingEvents() {\n\t\tif (!this.connected) return;\n\n\t\tlet events = this.pending;\n\t\tthis.pending = [];\n\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\tlet event = events[i];\n\t\t\tthis.hook.emit(event.type, event);\n\t\t}\n\t}\n\n\t/**\n\t * Recursively mount a vnode tree. Note that the devtools expects the tree to\n\t * be mounted from the bottom up, otherwise the order will be messed up.\n\t * Therefore we mount children prior to mounting the vnode itself.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\tmount(vnode) {\n\t\tthis.inst2vnode.set(getInstance(vnode), vnode);\n\t\tlet data = getData(vnode);\n\n\t\t/** @type {Array<import('../internal').DevtoolsEvent>} */\n\t\tlet work = [\n\t\t\t{\n\t\t\t\tinternalInstance: vnode,\n\t\t\t\tdata,\n\t\t\t\trenderer: this.rid,\n\t\t\t\ttype: 'mount'\n\t\t\t}\n\t\t];\n\n\t\t// Children must be mounted first\n\t\tif (Array.isArray(data.children)) {\n\t\t\tlet stack = data.children.slice();\n\t\t\tlet item;\n\t\t\twhile ((item = stack.pop()) != null) {\n\t\t\t\tlet children = getChildren(item);\n\t\t\t\tstack.push(...children);\n\n\t\t\t\tthis.inst2vnode.set(getInstance(item), item);\n\n\t\t\t\tlet data = getData(item);\n\n\t\t\t\twork.push({\n\t\t\t\t\tinternalInstance: item,\n\t\t\t\t\tdata,\n\t\t\t\t\trenderer: this.rid,\n\t\t\t\t\ttype: 'mount'\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = work.length; --i >= 0; ) {\n\t\t\tthis.pending.push(work[i]);\n\t\t}\n\n\t\t// Special event if we have a root\n\t\tif (isRoot(vnode)) {\n\t\t\tthis.pending.push({\n\t\t\t\tinternalInstance: vnode,\n\t\t\t\tdata,\n\t\t\t\trenderer: this.rid,\n\t\t\t\ttype: 'root'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update a vnode tree\n\t * @param {import('../internal').VNode} vnode\n\t */\n\tupdate(vnode) {\n\t\tlet data = getData(vnode);\n\n\t\t// Children must be updated first\n\t\tif (Array.isArray(data.children)) {\n\t\t\tfor (let i = 0; i < data.children.length; i++) {\n\t\t\t\tlet child = data.children[i];\n\t\t\t\tlet inst = getInstance(child);\n\n\t\t\t\tlet prevChild = this.inst2vnode.get(inst);\n\t\t\t\tif (prevChild == null) this.mount(child);\n\t\t\t\telse this.update(child);\n\n\t\t\t\t// Mutate child to keep referential equality intact\n\t\t\t\tdata.children[i] = this.inst2vnode.get(inst);\n\t\t\t}\n\t\t}\n\n\t\tlet prev = this.inst2vnode.get(data.publicInstance);\n\n\t\t// The `updateProfileTimes` event is a faster version of `updated` and\n\t\t// is processed much quicker inside the devtools extension.\n\t\tif (!hasDataChanged(prev, vnode)) {\n\t\t\t// Always assume profiling data has changed. When we skip an event here\n\t\t\t// the devtools element picker will somehow break.\n\t\t\tthis.pending.push({\n\t\t\t\t// This property is only used as an id inside the devtools. The\n\t\t\t\t// relevant data will be read from `.data` instead which is a\n\t\t\t\t// normalized structure that every react release adheres to. This\n\t\t\t\t// makes backwards-compatibility easier instead of relying on internal\n\t\t\t\t// vnode/fiber shape.\n\t\t\t\tinternalInstance: prev,\n\t\t\t\tdata,\n\t\t\t\trenderer: this.rid,\n\t\t\t\ttype: 'updateProfileTimes'\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tthis.pending.push({\n\t\t\t// This property is only used as an id inside the devtools. The\n\t\t\t// relevant data will be read from `.data` instead which is a\n\t\t\t// normalized structure that every react release adheres to. This\n\t\t\t// makes backwards-compatibility easier instead of relying on internal\n\t\t\t// vnode/fiber shape.\n\t\t\tinternalInstance: prev,\n\t\t\tdata,\n\t\t\trenderer: this.rid,\n\t\t\ttype: 'update'\n\t\t});\n\t}\n\n\t/**\n\t * Pass a rendered tree to the devtools. At this point elements have already\n\t * unmounted, so we don't need to check for removals and only update vs mount\n\t * instead.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\thandleCommitFiberRoot(vnode) {\n\t\tlet inst = getInstance(vnode);\n\n\t\tif (this.inst2vnode.has(inst)) this.update(vnode);\n\t\telse this.mount(vnode);\n\n\t\t// The devtools checks via the existence of this property if the devtools\n\t\t// profiler should be enabled or not. If it is missing from the first root\n\t\t// node the \"Profiler\" tab won't show up.\n\t\t/** @type {import('../internal').VNode} */\n\t\tlet root = null;\n\t\tif (isRoot(vnode)) {\n\t\t\t/** @type {*} */\n\t\t\t(vnode).treeBaseDuration = 0;\n\t\t\troot = vnode;\n\t\t} else {\n\t\t\t// \"rootCommitted\" always needs the actual root node for the profiler\n\t\t\t// to be able to collect timings. The `_parent` property will\n\t\t\t// point to a vnode for a root node.\n\t\t\troot = vnode;\n\t\t\twhile (root._parent != null) {\n\t\t\t\troot = root._parent;\n\t\t\t}\n\t\t}\n\n\t\tthis.pending.push({\n\t\t\tinternalInstance: root,\n\t\t\trenderer: this.rid,\n\t\t\tdata: getData(root),\n\t\t\ttype: 'rootCommitted'\n\t\t});\n\n\t\tthis.flushPendingEvents();\n\t\treturn vnode;\n\t}\n\n\t/**\n\t * Unmount a vnode recursively. Contrary to mounting or updating unmounting needs\n\t * to push the events in parent-first order. Because `options.unmount` is\n\t * already fired in parent-first order we don't need to traverse anything here.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\thandleCommitFiberUnmount(vnode) {\n\t\tlet inst = getInstance(vnode);\n\t\tthis.inst2vnode.delete(inst);\n\n\t\t// Special case when unmounting a root (most prominently caused by webpack's\n\t\t// `hot-module-reloading`). If this happens we need to unmount the virtual\n\t\t// `Fragment` we're wrapping around each root just for the devtools.\n\n\t\tthis.pending.push({\n\t\t\tinternalInstance: vnode,\n\t\t\trenderer: this.rid,\n\t\t\ttype: 'unmount'\n\t\t});\n\t}\n\n\t/**\n\t * Get the dom element by a vnode\n\t * @param {import('../internal').VNode} vnode\n\t * @returns {import('../internal').PreactElement | Text}\n\t */\n\tgetNativeFromReactElement(vnode) {\n\t\treturn vnode._dom;\n\t}\n\n\t/**\n\t * Get a vnode by a dom element\n\t * @param {import('../internal').PreactElement | Text} dom\n\t * @returns {import('../internal').VNode | null}\n\t */\n\tgetReactElementFromNative(dom) {\n\t\treturn this.inst2vnode.get(dom) || null;\n\t}\n\n\t// Unused, but devtools expects it to be there\n\t/* istanbul ignore next */\n\twalkTree() {}\n\n\t// Unused, but devtools expects it to be there\n\t/* istanbul ignore next */\n\tcleanup() {}\n}\n","/**\n * VNode relationships are encoded as simple numbers for the devtools. We use\n * this function to keep track of existing id's and create new ones if needed.\n * @returns {import('./types').IdMapper}\n */\nexport function createIdMapper() {\n\t/** @type {Map<any, number>} */\n\tconst instToId = new Map();\n\n\t/** @type {Map<number, import('../../internal').VNode>} */\n\tconst idToVNode = new Map();\n\n\t/** @type {Map<number, any>} */\n\tconst idToInst = new Map();\n\n\tlet nextId = 1;\n\n\t/** @type {import('./types').IdMapper[\"getVNode\"]} */\n\tconst getVNode = id => idToVNode.get(id) || null;\n\n\t/** @type {import('./types').IdMapper[\"hasId\"]} */\n\tconst hasId = vnode => {\n\t\t/* istanbul ignore next */\n\t\tif (vnode != null) {\n\t\t\treturn instToId.has(getInstance(vnode));\n\t\t}\n\t\t/* istanbul ignore next */\n\t\treturn false;\n\t};\n\n\t/** @type {import('./types').IdMapper[\"getId\"]} */\n\tconst getId = vnode => {\n\t\t/* istanbul ignore next */\n\t\tif (vnode == null) return -1;\n\t\tconst inst = getInstance(vnode);\n\t\treturn /* istanbul ignore next */ instToId.get(inst) || -1;\n\t};\n\n\t/** @type {import('./types').IdMapper[\"update\"]} */\n\tconst update = (id, vnode) => {\n\t\tconst inst = getInstance(vnode);\n\t\tidToInst.set(id, inst);\n\t\tidToVNode.set(id, vnode);\n\t};\n\n\t/** @type {import('./types').IdMapper[\"remove\"]} */\n\tconst remove = vnode => {\n\t\tif (hasId(vnode)) {\n\t\t\tconst id = getId(vnode);\n\t\t\tidToInst.delete(id);\n\t\t\tidToVNode.delete(id);\n\t\t}\n\t\tconst inst = getInstance(vnode);\n\t\tinstToId.delete(inst);\n\t};\n\n\t/** @type {import('./types').IdMapper[\"createId\"]} */\n\tconst createId = vnode => {\n\t\tconst id = nextId++;\n\t\tconst inst = getInstance(vnode);\n\t\tinstToId.set(inst, id);\n\t\tidToInst.set(id, inst);\n\t\tidToVNode.set(id, vnode);\n\t\treturn id;\n\t};\n\n\t/** @type {import('./types').IdMapper[\"has\"]} */\n\tconst has = id => idToInst.has(id);\n\n\treturn { has, update, getVNode, hasId, createId, getId, remove };\n}\n\n/**\n *\n * @param {import('../../internal').VNode} vnode\n */\nexport function getInstance(vnode) {\n\t// For components we use the instance to check refs, otherwise\n\t// we'll use a dom node\n\tif (typeof vnode.type === 'function') {\n\t\treturn vnode._component;\n\t}\n\n\treturn vnode._dom;\n}\n","/**\n * The string table holds a mapping of strings to ids. This saves a lot of space\n * in messaging because we can only need to declare a string once and can later\n * refer to its id. This is especially true for component or element names which\n * expectedoccur multiple times.\n */\n\n/**\n * Convert a string to an id. Works similar to a gzip dictionary.\n * @param {import('./types').StringTable} table\n * @param {string} input\n * @returns {number}\n */\nexport function getStringId(table, input) {\n\tif (!table.has(input)) {\n\t\ttable.set('' + input, table.size + 1);\n\t}\n\n\treturn table.get(input);\n}\n\n/**\n * Convert string table to something the extension understands\n * @param {import('./types').StringTable} table\n * @returns {number[]}\n */\nexport function flushTable(table) {\n\tlet ops = [0];\n\n\ttable.forEach((_, k) => {\n\t\tops[0] += k.length + 1;\n\t\tops.push(k.length, ...encode(k));\n\t});\n\n\treturn ops;\n}\n\n/**\n * Parse message to strings\n * @param {number[]} data\n */\nexport function parseTable(data) {\n\tconst len = data[0];\n\tconst strings = [];\n\tif (len > 0) {\n\t\tfor (let i = 1; i < len; i++) {\n\t\t\tconst strLen = data[i];\n\t\t\tlet start = i + 1;\n\t\t\tconst end = i + strLen + 1;\n\t\t\tlet str = '';\n\t\t\tfor (; start < end; start++) {\n\t\t\t\tstr += String.fromCodePoint(data[start]);\n\t\t\t}\n\t\t\tstrings.push(str);\n\t\t\ti += strLen;\n\t\t}\n\t}\n\n\treturn strings;\n}\n\n// TODO: Use a proper LRU cache?\n/** @type {Map<string, number[]>} */\nconst encoded = new Map();\n\n/** @type {(s: string) => number} */\nconst toCodePoint = s => s.codePointAt(0);\n\n/**\n * Convert a string to an array of codepoints\n * @param {string} input\n * @returns {number[]}\n */\nexport function encode(input) {\n\tif (!encoded.has(input)) {\n\t\tencoded.set(input, input.split('').map(toCodePoint));\n\t}\n\treturn encoded.get(input);\n}\n","import { Fragment } from 'preact';\n\n/**\n * Check if a `vnode` is the root of a tree\n * @param {import('../../internal').VNode} vnode\n * @returns {boolean}\n */\nexport function isRoot(vnode) {\n\treturn vnode._parent == null && vnode.type === Fragment;\n}\n\n/**\n * Check if a `vnode` represents a `Suspense` component\n * @param {import('../../internal').VNode} vnode\n * @returns {boolean}\n */\nexport function isSuspenseVNode(vnode) {\n\tconst c = vnode._component;\n\treturn c != null && c._suspensions != null;\n}\n\n/**\n * Check if a `vnode` represents a context `Consumer` component\n * @param {import('../../internal').VNode} vnode\n * @returns {boolean}\n */\nexport function isConsumerVNode(vnode) {\n\treturn getDisplayName(vnode) === 'Consumer';\n}\n\n/**\n * Get the internal hooks state of a component\n * @param {import('../../internal').Component} c\n */\n/* istanbul ignore next */\nexport function getComponentHooks(c) {\n\treturn c.__hooks || null;\n}\n\n/**\n * Get the diffed children of a `vnode`\n * @param {import('../../internal').VNode} vnode\n * @returns {Array<import('../../internal').VNode | null | undefined>}\n */\nexport function getActualChildren(vnode) {\n\treturn vnode._children || [];\n}\n\n// End Mangle accessors\n\n/**\n * Get the root of a `vnode`\n * @param {import('../../internal').VNode} vnode\n * @returns {import('../../internal').VNode}\n */\nexport function findRoot(vnode) {\n\tlet next = vnode;\n\twhile ((next = next._parent) != null) {\n\t\t/* istanbul ignore else */\n\t\tif (isRoot(next)) {\n\t\t\treturn next;\n\t\t}\n\t}\n\n\t/* istanbul ignore next */\n\treturn vnode;\n}\n\n/**\n * Get the ancestor component that rendered the current vnode\n * @param {import('../../internal').VNode} vnode\n */\nexport function getAncestor(vnode) {\n\tlet next = vnode;\n\twhile ((next = next._parent) != null) {\n\t\treturn next;\n\t}\n\n\t/* istanbul ignore next */\n\treturn null;\n}\n\n/**\n * Get human readable name of the component/dom element\n * @param {import('../../internal').VNode} vnode\n * @returns {string}\n */\n/* istanbul ignore next*/\nexport function getDisplayName(vnode) {\n\tif (vnode.type === Fragment) return 'Fragment';\n\telse if (typeof vnode.type === 'function')\n\t\treturn vnode.type.displayName || vnode.type.name;\n\telse if (typeof vnode.type === 'string') return vnode.type;\n\treturn '#text';\n}\n","import { Fragment } from 'preact';\nimport { getDisplayName } from './vnode';\n\n/**\n *\n * @param {import('../../internal').VNode} vnode\n * @param {import('./types').FilterState} filters\n * @returns {boolean}\n */\nexport function shouldFilter(vnode, filters) {\n\t// Filter text nodes by default. They are too tricky to match\n\t// with the previous one...\n\tif (vnode.type == null) return true;\n\n\tif (typeof vnode.type === 'function') {\n\t\tif (vnode.type === Fragment && filters.type.has('fragment')) {\n\t\t\tconst parent = vnode._parent;\n\t\t\t// Only filter non-root nodes\n\t\t\tif (parent != null) return true;\n\n\t\t\treturn false;\n\t\t}\n\t} else if (filters.type.has('dom')) {\n\t\treturn true;\n\t}\n\n\tif (filters.regex.length > 0) {\n\t\tconst name = getDisplayName(vnode);\n\t\treturn filters.regex.some(r => r.test(name));\n\t}\n\n\treturn false;\n}\n","import { getActualChildren } from './vnode';\n\n/**\n *\n * @param {import('../../internal').VNode} vnode\n * @param {(vnode: import('../../internal').VNode) => void} fn\n */\nexport function traverse(vnode, fn) {\n\tfn(vnode);\n\tconst children = getActualChildren(vnode);\n\tfor (let i = 0; i < children.length; i++) {\n\t\tconst child = /** @type {*} */ (children[i]);\n\t\t/* istanbul ignore else */\n\t\tif (child != null) {\n\t\t\tfn(child);\n\t\t}\n\t}\n}\n\n/**\n *\n * @param {*} data\n * @param {(x: any) => import('./types').SerializedVNode | null} getVNode\n * @param {Set<any>} [seen]\n */\nexport function jsonify(data, getVNode, seen = new Set()) {\n\tif (seen.has(data)) return '...';\n\n\tconst vnode = getVNode(data);\n\tif (vnode != null) return vnode;\n\n\tif (Array.isArray(data)) {\n\t\treturn data.map(x => jsonify(x, getVNode, seen));\n\t}\n\tswitch (typeof data) {\n\t\tcase 'string':\n\t\t\treturn data.length > 300 ? data.slice(300) : data;\n\t\tcase 'function': {\n\t\t\treturn {\n\t\t\t\ttype: 'function',\n\t\t\t\tname:\n\t\t\t\t\t/* istanbul ignore next */ data.displayName ||\n\t\t\t\t\tdata.name ||\n\t\t\t\t\t'anonymous'\n\t\t\t};\n\t\t}\n\t\tcase 'object': {\n\t\t\tif (data === null) return null;\n\t\t\tseen.add(data);\n\t\t\tconst out = { ...data };\n\t\t\tObject.keys(out).forEach(key => {\n\t\t\t\tout[key] = jsonify(out[key], getVNode, seen);\n\t\t\t});\n\t\t\treturn out;\n\t\t}\n\t\tdefault:\n\t\t\treturn data;\n\t}\n}\n\nexport function cleanProps(props) {\n\t/* istanbul ignore next */\n\tif (typeof props === 'string' || !props) return null;\n\tconst out = { ...props };\n\tif (!Object.keys(out).length) return null;\n\treturn out;\n}\n\nlet reg = /__cC\\d+/;\n\n/**\n *\n * @param {Record<string, any>} context\n */\nexport function cleanContext(context) {\n\tlet res = {};\n\tfor (let key in context) {\n\t\tif (reg.test(key)) continue;\n\t\tres[key] = context[key];\n\t}\n\n\tif (Object.keys(res).length == 0) return null;\n\treturn res;\n}\n\n/**\n * Deeply mutate a property by walking down an array of property keys\n * @param {Record<string, any>} obj\n * @param {Array<number | string>} path\n * @param {*} value\n */\nexport function setIn(obj, path, value) {\n\tlet last = path.pop();\n\t/* istanbul ignore next */\n\tlet parent = path.reduce((acc, attr) => (acc ? acc[attr] : null), obj);\n\t/* istanbul ignore else */\n\tif (parent && last) {\n\t\tparent[last] = value;\n\t}\n}\n","// Element types\nexport const HTML_ELEMENT = 1;\nexport const CLASS_COMPONENT = 2;\nexport const FUNCTION_COMPONENT = 3;\nexport const FORWARD_REF = 4;\nexport const MEMO = 5;\nexport const SUSPENSE = 6;\n\n// Devtools Event Messages\nexport const ADD_ROOT = 1;\nexport const ADD_VNODE = 2;\nexport const REMOVE_VNODE = 3;\nexport const UPDATE_VNODE_TIMINGS = 4;\nexport const REORDER_CHILDREN = 5;\n","import { Fragment } from 'preact';\nimport { createIdMapper } from './IdMapper';\nimport { getStringId, flushTable } from './string-table';\nimport {\n\tisRoot,\n\tfindRoot,\n\tgetAncestor,\n\tisSuspenseVNode,\n\tgetDisplayName,\n\tgetComponentHooks,\n\tgetActualChildren,\n\tisConsumerVNode\n} from './vnode';\nimport { shouldFilter } from './filter';\nimport { cleanContext, jsonify, cleanProps, traverse, setIn } from './utils';\nimport {\n\tMEMO,\n\tFORWARD_REF,\n\tSUSPENSE,\n\tCLASS_COMPONENT,\n\tFUNCTION_COMPONENT,\n\tHTML_ELEMENT,\n\tREMOVE_VNODE,\n\tADD_ROOT,\n\tADD_VNODE,\n\tUPDATE_VNODE_TIMINGS,\n\tREORDER_CHILDREN\n} from './constants';\n\nlet memoReg = /^Memo\\(/;\nlet forwardRefReg = /^ForwardRef\\(/;\n\n/**\n * Get the type of a vnode. The devtools uses these constants to differentiate\n * between the various forms of components.\n *\n * @param {import('../../internal').VNode} vnode\n * @returns {number}\n */\nexport function getDevtoolsType(vnode) {\n\tif (typeof vnode.type == 'function' && vnode.type !== Fragment) {\n\t\tconst name = getDisplayName(vnode);\n\t\tif (memoReg.test(name)) return MEMO;\n\t\tif (forwardRefReg.test(name)) return FORWARD_REF;\n\t\tif (isSuspenseVNode(vnode)) return SUSPENSE;\n\n\t\t// TODO: Provider and Consumer\n\t\treturn vnode.type.prototype && vnode.type.prototype.render\n\t\t\t? CLASS_COMPONENT\n\t\t\t: FUNCTION_COMPONENT;\n\t}\n\treturn HTML_ELEMENT;\n}\n\n/**\n * Check if a variable is a `vnode`\n * @param {*} x\n * @returns {boolean}\n */\nexport function isVNode(x) {\n\treturn x != null && x.type !== undefined && x._dom !== undefined;\n}\n\n/**\n * Serialize a vnode\n * @param {*} x\n * @returns {import('./types').SerializedVNode |null}\n */\nexport function serializeVNode(x) {\n\tif (isVNode(x)) {\n\t\treturn {\n\t\t\ttype: 'vnode',\n\t\t\tname: getDisplayName(x)\n\t\t};\n\t}\n\n\treturn null;\n}\n\n/**\n * Collect all relevant data from a commit and convert it to a message\n * the detools can understand\n * @param {import('./types').Commit} commit\n */\nexport function flush(commit) {\n\tconst { rootId, unmountIds, operations, strings } = commit;\n\n\tlet msg = [rootId, ...flushTable(strings)];\n\tif (unmountIds.length > 0) {\n\t\tmsg.push(REMOVE_VNODE, unmountIds.length, ...unmountIds);\n\t}\n\tmsg.push(...operations);\n\n\treturn { name: 'operation', data: msg };\n}\n\n/** @type {import('./types').FilterState} */\nlet defaultFilters = {\n\tregex: [],\n\ttype: new Set(['dom', 'fragment'])\n};\n\n/**\n * The renderer is responsible for translating anything preact rendered\n * into a serializable format that is passed to the devtools extension.\n * On top of that the devtools can call the renderer to request certain\n * information about `vnodes`. This is usually done lazily, so that we\n * don't waste any precious CPU time.\n *\n * Instead of passing `json` objects around, we're converting everythign\n * to a custom format that is representable using a number array. It's one\n * of the major performance improvements the react team made in their devtools\n * v4 code.\n *\n * The translation process always happens after a commit has finished.\n * This has the advantage of not tainting measured timings for rendering\n * `vnodes`. But it has the disadvantage that we need to reconstruct what\n * changes were done in each commit. Nonetheless I do think the additional\n * complexity is worth it, given the better and less confusing user experience.\n *\n * @param {import('./types').PreactDevtoolsHook} hook\n * @param {import('./types').FilterState} filters\n * @returns {import('./types').Renderer}\n */\nexport function createRenderer(hook, filters = defaultFilters) {\n\tconst ids = createIdMapper();\n\n\t/** @type {Set<import('../../internal').VNode>} */\n\tconst roots = new Set();\n\n\t/**\n\t * Queue events until the extension is connected\n\t * @type {import('./types').DevtoolsEvent[]}\n\t */\n\tlet queue = [];\n\n\t/** @type {number[]} */\n\tlet currentUnmounts = [];\n\n\t/** @type {WeakMap<HTMLElement | Text, import('../../internal').VNode>} */\n\tlet domToVNode = new WeakMap();\n\treturn {\n\t\tgetVNodeById: id => ids.getVNode(id),\n\t\thas: id => ids.has(id),\n\t\tgetDisplayName,\n\t\tforceUpdate: id => {\n\t\t\tconst vnode = ids.getVNode(id);\n\t\t\tif (vnode) {\n\t\t\t\tconst c = vnode._component;\n\t\t\t\tif (c) c.forceUpdate();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Print out a `vnode` to the native devtools console. Called when\n\t\t * the bug icon is pressed in the devtools sidebar panel.\n\t\t * @param {number} id\n\t\t * @param {number[]} children\n\t\t */\n\t\t/* istanbul ignore next */\n\t\tlog(id, children) {\n\t\t\tconst vnode = ids.getVNode(id);\n\t\t\tif (vnode == null) {\n\t\t\t\tconsole.warn(`Could not find vnode with id ${id}`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogVNode(vnode, id, children);\n\t\t},\n\n\t\t/**\n\t\t * Retrieve all `vnode` details like `props`, `state` and `context`\n\t\t * to be displayed in the sidebar. We only request this information\n\t\t * when a `vnode` is selected in the devtools extension.\n\t\t * @param {number} id\n\t\t * @returns {import('./types').InspectData | null}\n\t\t */\n\t\tinspect(id) {\n\t\t\tconst vnode = ids.getVNode(id);\n\t\t\tif (!vnode) return null;\n\n\t\t\tconst c = vnode._component;\n\t\t\tconst hasState =\n\t\t\t\ttypeof vnode.type === 'function' &&\n\t\t\t\tc != null &&\n\t\t\t\tObject.keys(c.state).length > 0;\n\n\t\t\tconst hasHooks = c != null && getComponentHooks(c) != null;\n\t\t\tlet context = null;\n\t\t\tif (c != null) {\n\t\t\t\tcontext = isConsumerVNode(vnode)\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tvalue: c.context\n\t\t\t\t\t  }\n\t\t\t\t\t: cleanContext(c.context);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcontext: context != null ? jsonify(context, serializeVNode) : null,\n\t\t\t\tcanEditHooks: hasHooks,\n\t\t\t\thooks: null,\n\t\t\t\tid,\n\t\t\t\tname: getDisplayName(vnode),\n\t\t\t\tcanEditProps: true,\n\t\t\t\tprops: jsonify(cleanProps(vnode.props), serializeVNode),\n\t\t\t\tcanEditState: true,\n\t\t\t\tstate: hasState ? jsonify(c.state, serializeVNode) : null,\n\t\t\t\ttype: getDevtoolsType(vnode)\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Get the DOM nodes associated with a `vnode`. For `Fragments` this can be\n\t\t * a range of nodes (experimental).\n\t\t * @param {number} id\n\t\t * @returns {[HTMLElement | Text | null, HTMLElement | Text | null] | null}\n\t\t */\n\t\tfindDomForVNode(id) {\n\t\t\tconst vnode = ids.getVNode(id);\n\t\t\treturn vnode ? [vnode._dom, vnode._lastDomChild] : null;\n\t\t},\n\n\t\t/**\n\t\t * Get the `id` associated with a `vnode`.\n\t\t * @param {HTMLElement | Text} node\n\t\t * @returns {number | null}\n\t\t */\n\t\tfindVNodeIdForDom(node) {\n\t\t\tconst vnode = domToVNode.get(node);\n\t\t\tif (vnode) {\n\t\t\t\tif (shouldFilter(vnode, filters)) {\n\t\t\t\t\tlet p = vnode;\n\t\t\t\t\twhile ((p = p._parent) != null) {\n\t\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\t\tif (!shouldFilter(p, filters)) break;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ids.getId(p);\n\t\t\t\t}\n\n\t\t\t\treturn ids.getId(vnode);\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t},\n\n\t\t/**\n\t\t * Called when the user changes filtering in the extension.\n\t\t * @param {import('./types').FilterState} nextFilters\n\t\t */\n\t\tapplyFilters(nextFilters) {\n\t\t\troots.forEach(root => {\n\t\t\t\tconst children = getActualChildren(root);\n\t\t\t\t/* istanbul ignore else */\n\t\t\t\tif (children.length > 0 && children[0] != null) {\n\t\t\t\t\ttraverse(/** @type{*} */ (children[0]), vnode =>\n\t\t\t\t\t\tthis.onUnmount(vnode)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t/** @type {import('./types').Commit} */\n\t\t\t\tconst commit = {\n\t\t\t\t\toperations: [],\n\t\t\t\t\trootId: ids.getId(root),\n\t\t\t\t\tstrings: new Map(),\n\t\t\t\t\tunmountIds: currentUnmounts\n\t\t\t\t};\n\n\t\t\t\tconst unmounts = flush(commit);\n\t\t\t\tcurrentUnmounts = [];\n\t\t\t\tqueue.push(unmounts);\n\t\t\t});\n\n\t\t\tfilters.regex = nextFilters.regex;\n\t\t\tfilters.type = nextFilters.type;\n\n\t\t\troots.forEach(root => {\n\t\t\t\tconst commit = createCommit(ids, roots, root, filters, domToVNode);\n\t\t\t\tconst ev = flush(commit);\n\t\t\t\tqueue.push(ev);\n\t\t\t});\n\n\t\t\t/* istanbul ignore else */\n\t\t\tif (hook.connected) {\n\t\t\t\tthis.flushInitial();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Flush all events that may have been queued before the devtools are\n\t\t * done initializing.\n\t\t */\n\t\tflushInitial() {\n\t\t\tqueue.forEach(ev => hook.emit(ev.name, ev.data));\n\t\t\thook.connected = true;\n\t\t\tqueue = [];\n\t\t},\n\n\t\t/**\n\t\t * Main entry function that's called whenever a commit completed. From here\n\t\t * on we walk the view tree and store any changes in an operations array\n\t\t * that the devtools can understand. If we're connected to the extension\n\t\t * we message the events, and if not we'll queue them until the extension\n\t\t * becomes active.\n\t\t * @param {import('../../internal').VNode} vnode\n\t\t */\n\t\tonCommit(vnode) {\n\t\t\tconst commit = createCommit(ids, roots, vnode, filters, domToVNode);\n\t\t\tcommit.unmountIds.push(...currentUnmounts);\n\t\t\tcurrentUnmounts = [];\n\t\t\tconst ev = flush(commit);\n\n\t\t\t/* istanbul ignore else */\n\t\t\tif (hook.connected) {\n\t\t\t\thook.emit(ev.name, ev.data);\n\t\t\t} else {\n\t\t\t\tqueue.push(ev);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Called when a `vnode` is removed.\n\t\t * @param {import('../../internal').VNode} vnode\n\t\t */\n\t\tonUnmount(vnode) {\n\t\t\tif (!shouldFilter(vnode, filters)) {\n\t\t\t\t/* istanbul ignore else */\n\t\t\t\tif (ids.hasId(vnode)) {\n\t\t\t\t\tcurrentUnmounts.push(ids.getId(vnode));\n\t\t\t\t}\n\t\t\t} else if (typeof vnode.type !== 'function') {\n\t\t\t\tconst dom = vnode._dom;\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tif (dom != null) domToVNode.delete(dom);\n\t\t\t}\n\n\t\t\tids.remove(vnode);\n\t\t},\n\n\t\t/**\n\t\t * Apply an update that was triggered in the extension. That's usually\n\t\t * done via any of the input elements in the sidebar.\n\t\t * @param {number} id\n\t\t * @param {'props' | 'state' | 'context' | 'hooks'} type\n\t\t * @param {Array<string, number>} path\n\t\t * @param {any} value\n\t\t */\n\t\tupdate(id, type, path, value) {\n\t\t\tconst vnode = ids.getVNode(id);\n\t\t\tif (vnode !== null) {\n\t\t\t\tif (typeof vnode.type === 'function') {\n\t\t\t\t\tconst c = vnode._component;\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif (type === 'props') {\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tsetIn(vnode.props || {}, path.slice(), value);\n\t\t\t\t\t} else if (type === 'state') {\n\t\t\t\t\t\tsetIn(c.state || {}, path.slice(), value);\n\t\t\t\t\t} else if (type === 'context') {\n\t\t\t\t\t\tsetIn(c.context || {}, path.slice(), value);\n\t\t\t\t\t}\n\n\t\t\t\t\tc.forceUpdate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Print an element to console\n * @param {import('../../internal').VNode} vnode\n * @param {number} id\n * @param {number[]} children\n */\n/* istanbul ignore next */\nexport function logVNode(vnode, id, children) {\n\tconst display = getDisplayName(vnode);\n\tconst name = display === '#text' ? display : `<${display || 'Component'} />`;\n\n\t/* eslint-disable no-console */\n\tconsole.group(`LOG %c${name}`, 'color: #ea88fd; font-weight: normal');\n\tconsole.log('props:', vnode.props);\n\tconst c = vnode._component;\n\tif (c != null) {\n\t\tconsole.log('state:', c.state);\n\t}\n\tconsole.log('vnode:', vnode);\n\tconsole.log('devtools id:', id);\n\tconsole.log('devtools children:', children);\n\tconsole.groupEnd();\n\t/* eslint-enable no-console */\n}\n\n/**\n * Walk a `vnode` tree and compare it with the previous one. If any\n * changes are detected they will be stored in the return value.\n * @param {import('./types').IdMapper} ids\n * @param {Set<import('../../internal').VNode>} roots\n * @param {import('../../internal').VNode} vnode\n * @param {import('./types').FilterState} filters\n * @param {WeakMap<HTMLElement | Text, import('../../internal').VNode>} filters\n * @returns {import('./types').Commit}\n */\nexport function createCommit(ids, roots, vnode, filters, domCache) {\n\tconst commit = {\n\t\toperations: [],\n\t\trootId: -1,\n\t\tstrings: new Map(),\n\t\tunmountIds: []\n\t};\n\n\tlet parentId = -1;\n\n\tconst isNew = !ids.hasId(vnode);\n\n\tif (isRoot(vnode)) {\n\t\tconst rootId = !isNew ? ids.getId(vnode) : ids.createId(vnode);\n\t\tparentId = commit.rootId = rootId;\n\t\troots.add(vnode);\n\t} else {\n\t\tconst root = findRoot(vnode);\n\t\tcommit.rootId = ids.getId(root);\n\t\tparentId = ids.getId(getAncestor(vnode));\n\t}\n\n\tif (isNew) {\n\t\tmount(ids, commit, vnode, parentId, filters, domCache);\n\t} else {\n\t\tupdate(ids, commit, vnode, parentId, filters, domCache);\n\t}\n\n\treturn commit;\n}\n\n/**\n * Mount a `vnode`\n * @param {import('./types').IdMapper} ids\n * @param {import('./types').Commit} commit\n * @param {import('../../internal').VNode} vnode\n * @param {number} ancestorId\n * @param {import('./types').FilterState} filters\n * @param {WeakMap<HTMLElement | Text, import('../../internal').VNode>} filters\n */\nexport function mount(ids, commit, vnode, ancestorId, filters, domCache) {\n\tconst root = isRoot(vnode);\n\n\tconst skip = shouldFilter(vnode, filters);\n\tif (root || !skip) {\n\t\tconst id = ids.hasId(vnode) ? ids.getId(vnode) : ids.createId(vnode);\n\t\tif (isRoot(vnode)) {\n\t\t\tcommit.operations.push(ADD_ROOT, id);\n\t\t}\n\n\t\tcommit.operations.push(\n\t\t\tADD_VNODE,\n\t\t\tid,\n\t\t\tgetDevtoolsType(vnode), // Type\n\t\t\tancestorId,\n\t\t\t9999, // owner\n\t\t\tgetStringId(commit.strings, getDisplayName(vnode)),\n\t\t\tvnode.key ? getStringId(commit.strings, vnode.key) : 0\n\t\t);\n\t\tancestorId = id;\n\t}\n\n\tif (typeof vnode.type !== 'function') {\n\t\tconst dom = vnode._dom;\n\t\t// TODO: Find a test case\n\t\t/* istanbul ignore next */\n\t\tif (dom) domCache.set(dom, vnode);\n\t}\n\n\tconst children = getActualChildren(vnode);\n\tfor (let i = 0; i < children.length; i++) {\n\t\tconst child = /** @type {*} */ (children[i]);\n\t\tif (child != null) {\n\t\t\tmount(ids, commit, child, ancestorId, filters, domCache);\n\t\t}\n\t}\n}\n\n/**\n * Mark parent vnode for recalculation of children\n * @param {import('./types').IdMapper} ids\n * @param {import('./types').Commit} commit\n * @param {import('../../internal').VNode} vnode\n * @param {number} ancestorId\n * @param {import('./types').FilterState} filters\n * @param {WeakMap<HTMLElement | Text, import('../../internal').VNode>} filters\n */\nexport function update(ids, commit, vnode, ancestorId, filters, domCache) {\n\tconst skip = shouldFilter(vnode, filters);\n\tif (skip) {\n\t\tconst children = getActualChildren(vnode);\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst child = /** @type {*} */ (children[i]);\n\t\t\tif (child != null) {\n\t\t\t\tupdate(ids, commit, child, ancestorId, filters, domCache);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!ids.hasId(vnode)) {\n\t\tmount(ids, commit, vnode, ancestorId, filters, domCache);\n\t\treturn true;\n\t}\n\n\tconst id = ids.getId(vnode);\n\tcommit.operations.push(\n\t\tUPDATE_VNODE_TIMINGS,\n\t\tid,\n\t\tvnode.endTime - vnode.startTime\n\t);\n\n\tids.update(id, vnode);\n\tlet shouldReorder = false;\n\n\tconst children = getActualChildren(vnode);\n\tfor (let i = 0; i < children.length; i++) {\n\t\tconst child = /** @type {*} */ (children[i]);\n\t\tif (child == null) {\n\t\t} else if (ids.hasId(child) || shouldFilter(child, filters)) {\n\t\t\tupdate(ids, commit, child, id, filters, domCache);\n\t\t\t// TODO: This is only sometimes necessary\n\t\t\tshouldReorder = true;\n\t\t} else {\n\t\t\tmount(ids, commit, child, id, filters, domCache);\n\t\t\tshouldReorder = true;\n\t\t}\n\t}\n\n\tif (shouldReorder) {\n\t\tresetChildren(commit, ids, id, vnode, filters);\n\t}\n}\n\n/**\n * Mark parent vnode for recalculation of children\n * @param {import('./types').Commit} commit\n * @param {import('./types').IdMapper} ids\n * @param {number} id\n * @param {import('../../internal').VNode} vnode\n * @param {import('./types').FilterState} filters\n */\nexport function resetChildren(commit, ids, id, vnode, filters) {\n\tlet next = getFilteredChildren(vnode, filters);\n\tif (next.length < 2) return;\n\n\tcommit.operations.push(\n\t\tREORDER_CHILDREN,\n\t\tid,\n\t\tnext.length,\n\t\t...next.map(x => ids.getId(x))\n\t);\n}\n\n/**\n * Traverse over children that are filtered away\n * @param {import('../../internal').VNode} vnode\n * @param {import('./types').FilterState} filters\n * @returns {import('../../internal').VNode[]}\n */\nexport function getFilteredChildren(vnode, filters) {\n\tconst children = getActualChildren(vnode);\n\tconst stack = children.slice();\n\n\t/** @type {import('../../internal').VNode[]} */\n\tconst out = [];\n\n\t/** @type {import('../../internal').VNode<any>} */\n\tlet child;\n\twhile (stack.length) {\n\t\tchild = /** @type {*} */ (stack.pop());\n\t\tif (child != null) {\n\t\t\tif (!shouldFilter(child, filters)) {\n\t\t\t\tout.push(child);\n\t\t\t} else {\n\t\t\t\tconst nextChildren = getActualChildren(child);\n\t\t\t\tif (nextChildren.length > 0) {\n\t\t\t\t\tstack.push(...nextChildren.slice());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn out.reverse();\n}\n","/* istanbul ignore file */\nimport { options, Component, Fragment } from 'preact';\nimport { Renderer } from './renderer';\nimport { setupOptions } from './10/options';\nimport { createRenderer } from './10/renderer';\n\n/**\n * Wrap function with generic error logging\n *\n * @param {*} fn\n * @returns\n */\nfunction catchErrors(fn) {\n\treturn function(...args) {\n\t\ttry {\n\t\t\treturn fn(...args);\n\t\t} catch (e) {\n\t\t\t/* istanbul ignore next */\n\t\t\tconsole.error('The react devtools encountered an error');\n\t\t\t/* istanbul ignore next */\n\t\t\tconsole.error(e); // eslint-disable-line no-console\n\t\t}\n\t};\n}\n\n/* istanbul ignore next */\nlet noop = () => undefined;\n\nexport function initDevTools() {\n\t// This global variable is injected by the devtools\n\tlet preactHook = /** @type {*} */ (window).__PREACT_DEVTOOLS__;\n\n\t// Check for Preact devtools first :)\n\tif (preactHook) {\n\t\tconst renderer = createRenderer(preactHook);\n\t\tsetupOptions(/** @type {*} */ (options), renderer);\n\t\tpreactHook.attach(renderer);\n\t\treturn;\n\t}\n\n\t/** @type {import('../internal').DevtoolsWindow} */\n\tlet hook = (window).__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\tif (hook == null) return;\n\n\t/** @type {(vnode: import('../internal').VNode) => void} */\n\tlet onCommitRoot = noop;\n\n\t/** @type {(vnode: import('../internal').VNode) => void} */\n\tlet onCommitUnmount = noop;\n\n\t// Initialize our custom renderer\n\tlet rid = Math.random()\n\t\t.toString(16)\n\t\t.slice(2);\n\tlet preactRenderer = new Renderer(hook, rid);\n\n\tcatchErrors(() => {\n\t\tlet isDev = false;\n\t\ttry {\n\t\t\tisDev = process.env.NODE_ENV !== 'production';\n\t\t} catch (e) {}\n\n\t\t// Tell devtools which bundle type we run in\n\t\twindow.parent.postMessage(\n\t\t\t{\n\t\t\t\tsource: 'react-devtools-detector',\n\t\t\t\treactBuildType: /* istanbul ignore next */ isDev\n\t\t\t\t\t? 'development'\n\t\t\t\t\t: 'production'\n\t\t\t},\n\t\t\t'*'\n\t\t);\n\n\t\tlet renderer = {\n\t\t\tbundleType: /* istanbul ignore next */ isDev ? 1 : 0,\n\t\t\tversion: '16.5.2',\n\t\t\trendererPackageName: 'preact',\n\t\t\t// We don't need this, but the devtools `attachRenderer` function relies on\n\t\t\t// it being there.\n\t\t\tfindHostInstanceByFiber(vnode) {\n\t\t\t\treturn vnode._dom;\n\t\t\t},\n\t\t\t// We don't need this, but the devtools `attachRenderer` function relies on\n\t\t\t// it being there.\n\t\t\tfindFiberByHostInstance(instance) {\n\t\t\t\treturn preactRenderer.inst2vnode.get(instance) || null;\n\t\t\t}\n\t\t};\n\n\t\tif (!hook._renderers) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.info(\n\t\t\t\t'Preact is not compatible with your version of react-devtools. We ' +\n\t\t\t\t\t'will address this in future releases.'\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\thook._renderers[rid] = renderer;\n\n\t\t// We can't bring our own `attachRenderer` function therefore we simply\n\t\t// prevent the devtools from overwriting our custom renderer by creating\n\t\t// a noop setter.\n\t\tObject.defineProperty(hook.helpers, rid, {\n\t\t\tget: () => preactRenderer,\n\t\t\tset: () => {\n\t\t\t\tif (!preactRenderer.connected) {\n\t\t\t\t\thelpers.markConnected();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tlet helpers = hook.helpers[rid];\n\n\t\t// Tell the devtools that we are ready to start\n\t\thook.emit('renderer-attached', {\n\t\t\tid: rid,\n\t\t\trenderer,\n\t\t\thelpers\n\t\t});\n\n\t\tonCommitRoot = catchErrors(root => {\n\t\t\t// Empty root\n\t\t\tif (root.type === Fragment && root._children.length == 0) return;\n\n\t\t\tlet roots = hook.getFiberRoots(rid);\n\t\t\troot = helpers.handleCommitFiberRoot(root);\n\t\t\tif (!roots.has(root)) roots.add(root);\n\t\t});\n\n\t\tonCommitUnmount = catchErrors(vnode => {\n\t\t\thook.onCommitFiberUnmount(rid, vnode);\n\t\t});\n\t})();\n\n\t// Store (possible) previous hooks so that we don't overwrite them\n\tlet prevVNodeHook = options.vnode;\n\tlet prevCommitRoot = options._commit;\n\tlet prevBeforeUnmount = options.unmount;\n\tlet prevBeforeDiff = options._diff;\n\tlet prevAfterDiff = options.diffed;\n\n\toptions.vnode = vnode => {\n\t\t// Tiny performance improvement by initializing fields as doubles\n\t\t// from the start. `performance.now()` will always return a double.\n\t\t// See https://github.com/facebook/react/issues/14365\n\t\t// and https://slidr.io/bmeurer/javascript-engine-fundamentals-the-good-the-bad-and-the-ugly\n\t\tvnode.startTime = NaN;\n\t\tvnode.endTime = NaN;\n\n\t\tvnode.startTime = 0;\n\t\tvnode.endTime = -1;\n\t\tif (prevVNodeHook) prevVNodeHook(vnode);\n\t};\n\n\toptions._diff = vnode => {\n\t\tvnode.startTime = now();\n\t\tif (prevBeforeDiff != null) prevBeforeDiff(vnode);\n\t};\n\n\toptions.diffed = vnode => {\n\t\tvnode.endTime = now();\n\t\tif (prevAfterDiff != null) prevAfterDiff(vnode);\n\t};\n\n\toptions._commit = catchErrors((vnode, commitQueue) => {\n\t\t// Call previously defined hook\n\t\tif (prevCommitRoot != null) prevCommitRoot(vnode, commitQueue);\n\n\t\t// These cases are already handled by `unmount`\n\t\tif (vnode == null) return;\n\t\tonCommitRoot(vnode);\n\t});\n\n\toptions.unmount = catchErrors(vnode => {\n\t\t// Call previously defined hook\n\t\tif (prevBeforeUnmount != null) prevBeforeUnmount(vnode);\n\t\tonCommitUnmount(vnode);\n\t});\n\n\t// Inject tracking into setState\n\tconst setState = Component.prototype.setState;\n\tComponent.prototype.setState = function(update, callback) {\n\t\t// Duplicated in setState() but doesn't matter due to the guard.\n\t\tlet s =\n\t\t\t(this._nextState !== this.state && this._nextState) ||\n\t\t\t(this._nextState = Object.assign({}, this.state));\n\n\t\t// Needed in order to check if state has changed after the tree has been committed:\n\t\tthis._prevState = Object.assign({}, s);\n\n\t\treturn setState.call(this, update, callback);\n\t};\n}\n\n/**\n * Get current timestamp in ms. Used for profiling.\n * @returns {number}\n */\nexport let now = Date.now;\n\ntry {\n\t/* istanbul ignore else */\n\tnow = performance.now.bind(performance);\n} catch (e) {}\n","import { initDebug } from './debug';\nimport { initDevTools } from './devtools';\n\nif (process.env.NODE_ENV === 'development') {\n\tinitDebug();\n\tinitDevTools();\n}\n","/**\n *\n * @param {import('../../internal').Options} options\n * @param {import('./types').Renderer} renderer\n */\nexport function setupOptions(options, renderer) {\n\t// Store (possible) previous hooks so that we don't overwrite them\n\tlet prevVNodeHook = options.vnode;\n\tlet prevCommitRoot = options._commit;\n\tlet prevBeforeUnmount = options.unmount;\n\tlet prevBeforeDiff = options._diff;\n\tlet prevAfterDiff = options.diffed;\n\n\toptions.vnode = vnode => {\n\t\t// Tiny performance improvement by initializing fields as doubles\n\t\t// from the start. `performance.now()` will always return a double.\n\t\t// See https://github.com/facebook/react/issues/14365\n\t\t// and https://slidr.io/bmeurer/javascript-engine-fundamentals-the-good-the-bad-and-the-ugly\n\t\tvnode.startTime = NaN;\n\t\tvnode.endTime = NaN;\n\n\t\tvnode.startTime = 0;\n\t\tvnode.endTime = -1;\n\n\t\t/* istanbul ignore next */\n\t\tif (prevVNodeHook) prevVNodeHook(vnode);\n\t};\n\n\toptions._diff = vnode => {\n\t\tvnode.startTime = performance.now();\n\t\t/* istanbul ignore next */\n\t\tif (prevBeforeDiff != null) prevBeforeDiff(vnode);\n\t};\n\n\toptions.diffed = vnode => {\n\t\tvnode.endTime = performance.now();\n\n\t\t/* istanbul ignore next */\n\t\tif (prevAfterDiff) prevAfterDiff(vnode);\n\t};\n\n\toptions._commit = (vnode, queue) => {\n\t\t/* istanbul ignore next */\n\t\tif (prevCommitRoot) prevCommitRoot(vnode, queue);\n\n\t\t// These cases are already handled by `unmount`\n\t\t/* istanbul ignore next */\n\t\tif (vnode == null) return;\n\n\t\trenderer.onCommit(vnode);\n\t};\n\n\toptions.unmount = vnode => {\n\t\t/* istanbul ignore next */\n\n\t\tif (prevBeforeUnmount) prevBeforeUnmount(vnode);\n\t\trenderer.onUnmount(vnode);\n\t};\n\n\t// Teardown devtools options. Mainly used for testing\n\treturn () => {\n\t\toptions.unmount = prevBeforeUnmount;\n\t\toptions._commit = prevCommitRoot;\n\t\toptions.diffed = prevAfterDiff;\n\t\toptions._diff = prevBeforeDiff;\n\t\toptions.vnode = prevVNodeHook;\n\t};\n}\n"],"names":["loggedTypeFailures","getNodeType","vnode","type","Fragment","getDisplayName","displayName","name","setIn","obj","path","value","last","pop","parent","reduce","acc","attr","getData","c","_component","updater","Component","setState","bind","forceUpdate","setInState","prev","setInProps","props","setInContext","context","children","getChildren","duration","endTime","startTime","nodeType","ref","key","text","state","length","publicInstance","getInstance","memoizedInteractions","actualDuration","actualStartTime","treeBaseDuration","_children","filter","Boolean","isRoot","_parent","_dom","parentNode","shallowEqual","a","b","isProps","Object","keys","renderStack","ownerStack","getCurrentVNode","hasBabelPlugin","isPossibleOwner","getOwnerStack","stack","next","_owner","push","owner","source","__source","fileName","lineNumber","console","warn","isWeakMapSupported","WeakMap","prototype","update","callback","this","_vnode","_parentDom","call","serializeVNode","attrs","prop","hasOwnProperty","toString","JSON","stringify","Renderer","hook","rid","pending","inst2vnode","connected","markConnected","flushPendingEvents","events","i","event","emit","mount","set","data","work","internalInstance","renderer","Array","isArray","item","slice","child","inst","get","_prevState","hasDataChanged","handleCommitFiberRoot","has","root","handleCommitFiberUnmount","delete","getNativeFromReactElement","getReactElementFromNative","dom","walkTree","cleanup","getStringId","table","input","size","encoded","Map","toCodePoint","s","codePointAt","getActualChildren","shouldFilter","filters","regex","some","r","test","jsonify","getVNode","seen","Set","map","x","add","out","forEach","cleanProps","reg","HTML_ELEMENT","CLASS_COMPONENT","FUNCTION_COMPONENT","FORWARD_REF","MEMO","SUSPENSE","ADD_ROOT","ADD_VNODE","REMOVE_VNODE","UPDATE_VNODE_TIMINGS","REORDER_CHILDREN","memoReg","forwardRefReg","getDevtoolsType","_suspensions","isSuspenseVNode","render","undefined","isVNode","flush","commit","ops","unmountIds","operations","msg","rootId","strings","_","k","split","defaultFilters","createCommit","ids","roots","domCache","parentId","isNew","hasId","createId","getId","findRoot","getAncestor","ancestorId","id","shouldReorder","nextChildren","reverse","getFilteredChildren","resetChildren","skip","catchErrors","fn","e","error","noop","now","Date","performance","process","env","NODE_ENV","oldDiff","options","_diff","oldDiffed","diffed","oldRoot","_root","oldVNode","oldRender","_render","setupComponentStack","oldBeforeDiff","oldVnode","oldCatchError","_catchError","oldHook","_hook","warnedComponents","useEffect","useLayoutEffect","lazyPropTypes","then","promise","Error","_childDidSuspend","isValid","componentName","typeSpecs","values","location","parentVNode","getClosestDomNodeParent","_lastDomChild","propTypes","m","lazyVNode","typeSpecName","message","comp","property","err","deprecatedAttributes","nodeName","attributes","self","__self","defineProperties","_depth","join","component","__hooks","hooks","_list","_factory","_args","_pendingEffects","effect","_renderCallbacks","possibleEffect","_value","indexOf","initDebug","preactHook","window","__PREACT_DEVTOOLS__","instToId","idToVNode","idToInst","nextId","remove","queue","currentUnmounts","domToVNode","getVNodeById","log","display","group","groupEnd","logVNode","inspect","hasState","hasHooks","getComponentHooks","isConsumerVNode","res","cleanContext","canEditHooks","canEditProps","canEditState","findDomForVNode","findVNodeIdForDom","node","p","applyFilters","nextFilters","traverse","_this","onUnmount","unmounts","ev","flushInitial","onCommit","createRenderer","prevVNodeHook","prevCommitRoot","_commit","prevBeforeUnmount","unmount","prevBeforeDiff","prevAfterDiff","NaN","setupOptions","attach","__REACT_DEVTOOLS_GLOBAL_HOOK__","onCommitRoot","onCommitUnmount","Math","random","preactRenderer","isDev","postMessage","reactBuildType","bundleType","version","rendererPackageName","findHostInstanceByFiber","findFiberByHostInstance","instance","_renderers","defineProperty","helpers","getFiberRoots","onCommitFiberUnmount","info","commitQueue","_nextState","assign","initDevTools"],"mappings":"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"}