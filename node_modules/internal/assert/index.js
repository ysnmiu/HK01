'use strict';

const toString = {}.toString;
const Node = typeof window != 'undefined' ? window.Node : Function; // could be any function




























/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @api public
 */

function type(x) {
  var type = typeof x;
  if (type != 'object') {
    return type
  }
  let otype = types[toString.call(x)];
  if (otype == 'object') {
    // in case they have been polyfilled
    if (x instanceof Map) return 'map'
    if (x instanceof Set) return 'set'
    return 'object'
  }
  if (otype) {
    return otype
  }
  if (x instanceof Node && 'nodeType' in x) {
    switch (x.nodeType) {
      case 1:
        return 'element'
      case 3:
        return 'text-node'
      case 9:
        return 'document'
      case 11:
        return 'document-fragment'
      default:
        return 'dom-node'
    }
  }
  throw new Error('internal/type: unhandled type: ' + x)
}

const types = {
  '[object Function]': 'function',
  '[object Date]': 'date',
  '[object RegExp]': 'regexp',
  '[object Arguments]': 'arguments',
  '[object Array]': 'array',
  '[object Set]': 'set',
  '[object String]': 'string',
  '[object Null]': 'null',
  '[object Undefined]': 'undefined',
  '[object Number]': 'number',
  '[object Boolean]': 'boolean',
  '[object Object]': 'object',
  '[object Map]': 'map',
  '[object Text]': 'text-node',
  '[object Uint8Array]': 'bit-array',
  '[object Uint16Array]': 'bit-array',
  '[object Uint32Array]': 'bit-array',
  '[object Uint8ClampedArray]': 'bit-array',
  '[object Error]': 'error',
  '[object FormData]': 'form-data',
  '[object File]': 'file',
  '[object Blob]': 'blob',
};

// (any, any, [array]) -> boolean
function equal(a, b, memos) {
  // All identical values are equivalent
  if (a === b) return true
  const fnA = types$1[type(a)];
  const fnB = types$1[type(b)];
  return fnA && fnA === fnB ? fnA(a, b, memos) : false
}

const types$1 = {};

// (Number) -> boolean
types$1.number = function(a, b) {
  return a !== a && b !== b /*Nan check*/
};

// (function, function, array) -> boolean
types$1['function'] = function(
  a,
  b,
  memos
) {
  return (
    a.toString() === b.toString() &&
    // Functions can act as objects
    types$1.object(a, b, memos) &&
    equal(a.prototype, b.prototype)
  )
};

// (date, date) -> boolean
types$1.date = function(a, b) {
  return +a === +b
};

// (regexp, regexp) -> boolean
types$1.regexp = function(a, b) {
  return a.toString() === b.toString()
};

// (DOMElement, DOMElement) -> boolean
types$1.element = function(a, b) {
  return a.outerHTML === b.outerHTML
};

// (textnode, textnode) -> boolean
types$1.textnode = function(a, b) {
  return a.textContent === b.textContent
};

// decorate `fn` to prevent it re-checking objects
// (function) -> function
function memoGuard(fn) {
  return function(a, b, memos) {
    if (!memos) return fn(a, b, [])
    var i = memos.length,
      memo;
    while ((memo = memos[--i])) {
      if (memo[0] === a && memo[1] === b) return true
    }
    return fn(a, b, memos)
  }
}

types$1['arguments'] = types$1['bit-array'] = types$1.array = memoGuard(arrayEqual);

// (array, array, array) -> boolean
function arrayEqual(a, b, memos) {
  var i = a.length;
  if (i !== b.length) return false
  memos.push([a, b]);
  while (i--) {
    if (!equal(a[i], b[i], memos)) return false
  }
  return true
}

types$1.object = memoGuard(objectEqual);

// (object, object, array) -> boolean
function objectEqual(a, b, memos) {
  if (typeof a.equal == 'function') {
    memos.push([a, b]);
    return a.equal(b, memos)
  }
  var ka = getEnumerableProperties(a);
  var kb = getEnumerableProperties(b);
  var i = ka.length;

  // same number of properties
  if (i !== kb.length) return false

  // although not necessarily the same order
  ka.sort();
  kb.sort();

  // cheap key test
  while (i--) if (ka[i] !== kb[i]) return false

  // remember
  memos.push([a, b]);

  // iterate again this time doing a thorough check
  i = ka.length;
  while (i--) {
    var key = ka[i];
    if (!equal(a[key], b[key], memos)) return false
  }

  return true
}

// (object) -> array
const getEnumerableProperties = (object) => {
  const result = [];
  for (var k in object)
    if (k !== 'constructor') {
      result.push(k);
    }
  return result
};

/**
 * toString.
 */

const toString$1 =
  typeof window !== 'undefined' && window.JSON ? JSON.stringify : String;

/**
 * Formatters
 */

fmt.o = toString$1;
fmt.s = String;
fmt.d = parseInt;

/**
 * Format the given `str`.
 *
 * @param {String} str
 * @param {...} args
 * @return {String}
 * @api public
 */

function fmt(str, ...args) {
  var j = 0;
  return str.replace(/%([a-z])/gi, function(_, f) {
    // @ts-ignore
    return fmt[f] ? fmt[f](args[j++]) : _ + f
  })
}

/**
 * Module dependencies.
 */

/**
 * Assert `expr` with optional failure `msg`.
 *
 * @param {Mixed} expr
 * @param {String} [msg]
 * @api public
 */

function assert(expr, msg) {
  if (expr) return
  throw error(msg || message() || 'assertion failed')
}

/**
 * Ok is a simple alias
 */

assert.ok = assert;

/**
 * Assert `actual` is weak equal to `expected`.
 *
 * @param {Mixed} actual
 * @param {Mixed} expected
 * @param {String} [msg]
 * @api public
 */

assert.equal = function(actual, expected, msg) {
  if (actual == expected) return
  throw error(
    msg || fmt('Expected %o to equal %o.', actual, expected),
    actual,
    expected
  )
};

/**
 * Assert `actual` is not weak equal to `expected`.
 *
 * @param {Mixed} actual
 * @param {Mixed} expected
 * @param {String} [msg]
 * @api public
 */

assert.notEqual = function(actual, expected, msg) {
  if (actual != expected) return
  throw error(msg || fmt('Expected %o not to equal %o.', actual, expected))
};

/**
 * Assert `actual` is deep equal to `expected`.
 *
 * @param {Mixed} actual
 * @param {Mixed} expected
 * @param {String} [msg]
 * @api public
 */

assert.deepEqual = function(actual, expected, msg) {
  if (equal(actual, expected)) return
  throw error(
    msg || fmt('Expected %o to deeply equal %o.', actual, expected),
    actual,
    expected
  )
};

/**
 * Assert `actual` is not deep equal to `expected`.
 *
 * @param {Mixed} actual
 * @param {Mixed} expected
 * @param {String} [msg]
 * @api public
 */

assert.notDeepEqual = function(
  actual,
  expected,
  msg
) {
  if (!equal(actual, expected)) return
  throw error(
    msg || fmt('Expected %o not to deeply equal %o.', actual, expected)
  )
};

/**
 * Assert `actual` is strict equal to `expected`.
 *
 * @param {Mixed} actual
 * @param {Mixed} expected
 * @param {String} [msg]
 * @api public
 */

assert.strictEqual = function(
  actual,
  expected,
  msg
) {
  if (actual === expected) return
  throw error(
    msg || fmt('Expected %o to strictly equal %o.', actual, expected),
    actual,
    expected
  )
};

/**
 * Assert `actual` is not strict equal to `expected`.
 *
 * @param {Mixed} actual
 * @param {Mixed} expected
 * @param {String} [msg]
 * @api public
 */

assert.notStrictEqual = function(
  actual,
  expected,
  msg
) {
  if (actual !== expected) return
  throw error(
    msg || fmt('Expected %o not to strictly equal %o.', actual, expected)
  )
};

/**
 * Assert `block` throws an `error`.
 *
 * @param {Function} block
 * @param {Function} [error]
 * @param {String} [msg]
 * @api public
 */

assert.throws = function(block, err, msg) {
  var threw;
  try {
    block();
  } catch (e) {
    threw = e;
  }
  if (!threw)
    throw error(msg || fmt('Expected %s to throw an error.', block.toString()))
  if (err && !(threw instanceof err)) {
    throw error(
      msg || fmt('Expected %s to throw an %o.', block.toString(), err)
    )
  }
};

/**
 * Assert `block` doesn't throw an `error`.
 *
 * @param {Function} block
 * @param {Function} [error]
 * @param {String} [msg]
 * @api public
 */

assert.doesNotThrow = function(
  block,
  err,
  msg
) {
  var threw;
  try {
    block();
  } catch (e) {
    threw = e;
  }
  if (threw)
    throw error(
      msg || fmt('Expected %s not to throw an error.', block.toString())
    )
  if (err && threw instanceof err) {
    throw error(
      msg || fmt('Expected %s not to throw an %o.', block.toString(), err)
    )
  }
};

/**
 * Create a message from the call stack.
 *
 * @return {String}
 * @api private
 */

function message() {
  if (!Error.captureStackTrace) {
    return 'assertion failed'
  }
  var callsite = stack()[3];
  var file = callsite.getFileName();
  var lineno = (callsite.getLineNumber() || 0) - 1;
  var col = (callsite.getColumnNumber() || 0) - 1;
  var src = file ? get(file) : '';
  var line = src.split('\n')[lineno].slice(col);
  var m = line.match(/assert\((.*)\)/);
  return m && m[1].trim().replace(/\n/g, ' ')
}

/**
 * Load contents of `script`.
 *
 * @param {String} script
 * @return {String}
 * @api private
 */

function get(script) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', script, false);
  xhr.send(null);
  return xhr.responseText
}

/**
 * Error with `msg`, `actual` and `expected`.
 *
 * @param {String} msg
 * @param {Mixed} actual
 * @param {Mixed} expected
 * @return {Error}
 */







function error(msg, actual, expected) {
  var err = new Error(msg);
  err.showDiff = 3 == arguments.length;
  err.actual = actual;
  err.expected = expected;
  return err
}

/**
 * Return the stack.
 */

function stack() {
  var orig = Error.prepareStackTrace;
  Error.prepareStackTrace = function(_, stack) {
    return stack
  };
  var err = new Error();
  Error.captureStackTrace(err);
  var stack = err.stack;
  Error.prepareStackTrace = orig;
  return (stack ) 
}

module.exports = assert;
